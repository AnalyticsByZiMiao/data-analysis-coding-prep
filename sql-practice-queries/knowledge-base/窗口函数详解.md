# SQL 窗口函数 (Window Function) 核心学习笔记

> **整理日期:** 2025-09-09
> **关联面试:** 地上铁租车(深圳)有限公司-用户运营-二面-准备
> **关键词:** `#SQL`, `#数据分析`, `#窗口函数`, `#面试考点`

---

## 1. 核心概念与价值

**定义**
窗口函数（Window Function），也称为分析函数（Analytic Function），用于对一组与当前行相关的行（称为"窗口"）执行计算。其最核心的特性是：**在进行计算的同时，不会将多行合并为一行，而是为每一行返回一个值，同时保留原始行的所有细节**。这使得它非常适合进行排名、移动平均、累计计算等分析操作。

**与聚合函数的关键区别**
-   **聚合函数 + `GROUP BY`**: 将多行合并为一行，返回的是分组后的汇总结果。
-   **窗口函数 + `OVER()`**: 保留所有原始行，同时在每一行上添加基于窗口的计算结果。

**核心价值**
窗口函数极大地增强了 SQL 的数据分析能力，允许在单次查询中完成复杂的数据对比、趋势分析和分组计算，是高级数据分析与数据科学的必备技能。

---

## 2. 基本语法结构

窗口函数的核心语法如下所示：
``` sql
<窗口函数> OVER (

[PARTITION BY <列名1>[, <列名2>, ...]]

[ORDER BY <排序列1> [ASC|DESC][, <排序列2> [ASC|DESC], ...]]

[ROWS | RANGE BETWEEN <起始点> AND <结束点>]

)
```

**组成部分详解**
-   **`<窗口函数>`**: 可以是**专用窗口函数**（如 `RANK()`, `ROW_NUMBER()`）或**聚合函数**（如 `SUM()`, `AVG()`, `COUNT()`, `MAX()`, `MIN()`）。
-   **`PARTITION BY`**: 可选。用于将数据行划分为不同的分区（组），窗口函数会在**每个分区内独立进行计算**。如果省略，整个结果集被视为一个分区。
-   **`ORDER BY`**: 可选。用于指定**分区内**行的排序顺序。这对排名函数和计算累计值至关重要。
-   **`ROWS | RANGE BETWEEN`**: 可选。用于定义**窗口框架** (Window Frame)，即精确控制对于每一行，其计算所涉及的具体行范围。

---

## 3. 窗口框架 (Window Frame)

**定义**
窗口框架是窗口函数中更高级的功能，它能精确控制参与计算的行范围。

**类型**
-   **`ROWS`**: 基于**物理行**的偏移（如前2行，后1行）。
-   **`RANGE`**: 基于**逻辑值**的范围（例如，所有日期在最近3天内的行）。

**常用框架子句**
-   `ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`: 从分区**第一行到当前行**（这是使用 `ORDER BY` 时的默认框架）。
-   `ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING`: **当前行前3行到后1行**。
-   `ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING`: 从**当前行到分区最后一行**。
-   `RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND CURRENT ROW`: 值在（**当前行值 - 1天**）到当前行值之间的所有行（常用于计算移动平均）。

---

## 4. 常用窗口函数分类与应用

### 4.1 排序函数 (Ranking Functions)
-   **`ROW_NUMBER()`**: 为分区内的每一行分配一个**唯一的连续序号**（如：1, 2, 3, 4），即使值相同也会分配不同的编号。
-   **`RANK()`**: 排名，值相同时排名相同，但**后续排名会跳过**相同的序号（如：1, 1, 3, 4）。
-   **`DENSE_RANK()`**: 密集排名，值相同时排名相同，但**后续排名连续不跳跃**（如：1, 1, 2, 3）。

### 4.2 分布函数 (Distribution Functions)
-   **`NTILE(n)`**: 将分区内的有序数据**尽可能平均地分配到 `n` 个桶**中，并为每一行分配其所属的桶号（从1开始）。
-   **`PERCENT_RANK()`**: 计算行的相对排名（百分比），公式为 $\frac{RANK() - 1}{总行数 - 1}$，结果范围在 [0, 1]。
-   **`CUME_DIST()`**: 计算行的**累积分布**，即值小于或等于当前行值的行数占总行数的比例，范围在 (0, 1]。

### 4.3 偏移函数 (Offset Functions)
-   **`LAG(column, offset, default)`**: 访问当前行**之前** `offset`（默认为1）行的数据。如果不存在，则返回 `default`（默认为 NULL）。
-   **`LEAD(column, offset, default)`**: 访问当前行**之后** `offset`（默认为1）行的数据。如果不存在，则返回 `default`（默认为 NULL）。

### 4.4 首尾值函数 (Value Functions)
-   **`FIRST_VALUE(column)`**: 返回窗口框架内**第一行**的值。
-   **`LAST_VALUE(column)`**: 返回窗口框架内**最后一行**的值。**注意**：在默认框架下，`LAST_VALUE()` 会得到当前行的值。若要获取分区的最后一行，需指定 `ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING`。
-   **`NTH_VALUE(column, n)`**: 返回窗口框架内**第 n 行**的值。

### 4.5 聚合函数作为窗口函数
常见的聚合函数（`SUM()`, `AVG()`, `COUNT()`, `MAX()`, `MIN()`）与 `OVER()` 子句结合后，即可作为窗口函数使用，在定义的窗口上计算聚合值，同时保留所有原始行。

---

## 5. 实战应用场景与 SQL 示例

### 5.1 排名问题
-- 求每个部门内员工的薪水排名
``` sql
SELECT

department,

employee,

salary,

RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_salary,

DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_rank_salary,

ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num_salary

FROM employees;
```

### 5.2 Top-N 问题

-- 找出每个部门薪水最高的前3名员工
``` sql
WITH ranked_employees AS (

SELECT

department,

employee,

salary,

DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dr

FROM employees

)

SELECT *

FROM ranked_employees

WHERE dr <= 3;
```

### 5.3 累计计算

-- 计算每个产品按日期排序的累计销售额
```sql
SELECT

product_id,

sale_date,

daily_sales,

SUM(daily_sales) OVER (

PARTITION BY product_id

ORDER BY sale_date

ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW

) AS cumulative_sales

FROM sales;
```

### 5.4 移动平均/移动求和

-- 计算近3天的移动平均销售额（包括当天）
``` sql
SELECT

product_id,

sale_date,

daily_sales,

AVG(daily_sales) OVER (

PARTITION BY product_id

ORDER BY sale_date

ROWS BETWEEN 2 PRECEDING AND CURRENT ROW

) AS moving_avg_3day

FROM sales;
```

### 5.5 访问相邻行数据（同比/环比）

-- 计算月度销售额的环比增长
``` sql
SELECT

month,

revenue,

LAG(revenue, 1) OVER (ORDER BY month) AS prev_month_revenue,

revenue - LAG(revenue, 1) OVER (ORDER BY month) AS mom_growth

FROM monthly_sales;
```

### 5.6 计算占比

-- 计算每个员工的薪水占其部门总薪水的比例
``` sql
SELECT

department,

employee,

salary,

salary / SUM(salary) OVER (PARTITION BY department) * 100 AS salary_percentage

FROM employees;
```
---

## 6. 执行顺序与注意事项

**SQL 逻辑执行顺序**
窗口函数通常在 `WHERE`, `GROUP BY`, `HAVING` 之后，`ORDER BY` 之前进行计算。这意味着它操作的是这些子句处理后的结果集。

**重要注意事项**
-   **`PARTITION BY` vs `GROUP BY`**: `GROUP BY` 会压缩行，每个分组只返回一行汇总结果；`PARTITION BY` 不会减少原表的行数，只是划分计算范围。
-   **性能**: 为 `PARTITION BY` 和 `ORDER BY` 中使用的列建立索引可以提高窗口函数的查询性能。
-   **使用限制**: 窗口函数原则上只能写在 `SELECT` 子句中。

---

## ✨ 面试思考与技巧

**面试官考察意图**
面试官询问窗口函数，旨在考察你是否：
1.  掌握**高级 SQL 分析能力**，而不仅仅是基础的增删改查。
2.  能够使用窗口函数**解决复杂的业务分析问题**（如排名、趋势分析、对比）。
3.  理解不同窗口函数的**适用场景和细微区别**（如 `RANK` vs `DENSE_RANK`）。
4.  具备将**技术概念转化为业务语言**的能力，理解数据分析背后的商业价值。

**如何展现你的优势**
在回答时，不要只背诵概念和语法。要：
1.  **结合业务场景**: 举例说明你如何使用窗口函数解决实际问题。
    -   *“在分析用户活跃度时，我使用 `ROW_NUMBER()` 来识别每个用户最近一次的登录时间，从而定义流失用户。”*
    -   *“为了监控销售额的稳定性，我使用 `AVG() OVER()` 配合 `ROWS BETWEEN ...` 来计算移动平均线，消除短期波动，观察长期趋势。”*
    -   *“在做用户分层时，我使用 `NTILE(4)` 将用户按消费金额分为高、中高、中低、低四个价值层级，进行精准运营。”*
2.  **解释选择理由**: 说明为什么在这个场景下选择这个特定的窗口函数，而不是其他方法（如子查询或临时表）。
    -   *“使用窗口函数不仅让查询更简洁，而且性能通常更好，因为它避免了多次扫描表或创建临时表。”*
3.  **提及注意事项**: 简要说明使用时需要注意的点，能体现你的深度。
    -   *“在使用 `LAST_VALUE()` 时需要注意默认窗口框架的问题，通常需要指定 `ROWS BETWEEN ...` 来获取正确结果。”*
    -   *“在处理大量数据时，要注意 `PARTITION BY` 和 `ORDER BY` 的字段是否有索引，以避免性能瓶颈。”*