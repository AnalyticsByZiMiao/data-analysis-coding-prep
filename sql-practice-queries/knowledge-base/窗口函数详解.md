# SQL 窗口函数 (Window Function) 核心学习笔记

> 整理日期: 2025-09-09
> 关联面试: 地上铁租车(深圳)有限公司-用户运营-二面-准备
> 关键词: #SQL#数据分析#窗口函数#面试考点

---

## 1. 窗口函数核心概念
**​​定义​**​：窗口函数（Window Function），也称为分析函数（Analytic Function）或 OLAP 函数，用于对一组与当前行相关的行（称为"窗口"）执行计算。其最关键的特性是：​​在进行计算的同时，不会将多行合并为一行，而是为每一行返回一个值，同时保留原始行的所有细节​​。这使得它非常适合进行排名、移动平均、累计计算等分析操作。

**​​与聚合函数的区别**​​：
- **​​聚合函数**​​：将多行合并为一行（如 GROUP BY）
- **​​窗口函数​​**：保留所有原始行，同时添加计算结果

## 2. 基本语法结构
**​​核心语法**​​：
```sql
<窗口函数> OVER (
    [PARTITION BY <列名1>[, <列名2>, ...]]
    [ORDER BY <排序列1> [ASC|DESC][, <排序列2> [ASC|DESC], ...]]
    [ROWS | RANGE BETWEEN <起始点> AND <结束点>]
)
```

**​​组成部分**​​：
- **​​<窗口函数>​**​：专用窗口函数（如 RANK()）或聚合函数（如 SUM(), AVG()）

- **​​PARTITION BY**​​：将数据划分为不同分区，窗口函数在每个分区独立计算

- **​​ORDER BY​**​：指定分区内行的排序顺序

- **​​ROWS | RANGE BETWEEN​**​：定义窗口框架，控制计算涉及的行范围

## 3. 窗口框架（Window Frame）
**​​定义**​​：精确控制参与计算的行范围

**​​类型**​​：
- **​​ROWS**​​：基于物理行偏移
- **​​RANGE​**​：基于逻辑值范围

**​​常用框架子句**​​：
- **ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW**：分区第一行到当前行（默认）
- **ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING**：当前行前3行到后1行
- **ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING**：当前行到分区最后一行
- **RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND CURRENT ROW**：值在（当前行值-1天）到当前行值间所有行

## 4. 常用窗口函数分类
### 4.1 排序函数（Ranking Functions）
**​​ROW_NUMBER()**​​：分配唯一的连续序号（如：1, 2, 3, 4）
**​​RANK()​**​：排名相同则序号相同，后续排名跳过（如：1, 1, 3, 4）
**​​DENSE_RANK()​**​：排名相同则序号相同，后续排名连续（如：1, 1, 2, 3）

### 4.2 分布函数（Distribution Functions）
**​​NTILE(n)​**​：将数据分配到n个桶中，分配桶号
**​​PERCENT_RANK()​**​：计算相对排名百分比，公式为：
$$\text{PERCENT_RANK} = \frac{\text{RANK} - 1}{\text{总行数} - 1}$$
**​​CUME_DIST()​**​：计算累积分布，值≤当前行值的行数占比

### 4.3 偏移函数（Offset Functions）
**​​LAG(column, offset, default)​**​：访问当前行之前offset行的数据

**​​LEAD(column, offset, default)​**​：访问当前行之后offset行的数据

### 4.4 首尾值函数（Value Functions）
**​​FIRST_VALUE(column)​**​：返回窗口框架内第一行的值

**​​LAST_VALUE(column)​​**：返回窗口框架内最后一行的值

**​​NTH_VALUE(column, n)​**​：返回窗口框架内第n行的值

### 4.5 聚合函数作为窗口函数
常见聚合函数（SUM(), AVG(), COUNT(), MAX(), MIN()）与 OVER()结合使用

## 5. 应用场景与SQL示例
### 5.1 排名问题
-- 求每个部门内员工的薪水排名
``` sql
SELECT
    department,
    employee,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_salary,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_rank_salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num_salary
FROM employees;
```

### 5.2 Top-N问题
-- 找出每个部门薪水最高的前3名员工
```sql
WITH ranked_employees AS (
    SELECT
        department,
        employee,
        salary,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dr
    FROM employees
)
SELECT *
FROM ranked_employees
WHERE dr <= 3;
```

### 5.3 累计计算
-- 计算每个产品按日期排序的累计销售额
``` sql
SELECT
    product_id,
    sale_date,
    daily_sales,
    SUM(daily_sales) OVER (
        PARTITION BY product_id
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_sales
FROM sales;
```

### 5.4 移动平均/移动求和
-- 计算近3天的移动平均销售额（包括当天）
``` sql
SELECT
    product_id,
    sale_date,
    daily_sales,
    AVG(daily_sales) OVER (
        PARTITION BY product_id
        ORDER BY sale_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3day
FROM sales;
```

### 5.5 访问相邻行数据（同比/环比）
-- 计算月度销售额的环比增长
``` sql
SELECT
    month,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY month) AS prev_month_revenue,
    revenue - LAG(revenue, 1) OVER (ORDER BY month) AS mom_growth
FROM monthly_sales;
```

### 5.6 计算占比
-- 计算每个员工的薪水占其部门总薪水的比例
``` sql
SELECT
    department,
    employee,
    salary,
    salary / SUM(salary) OVER (PARTITION BY department) * 100 AS salary_percentage
FROM employees;
```

## 6. 执行顺序与注意事项
**​​SQL执行顺序​**​：窗口函数在 WHERE, GROUP BY, HAVING之后，ORDER BY之前进行计算

**​​重要区别​**​：
- **GROUP BY**：压缩行，每个分组返回一行汇总结果
- **PARTITION BY**：不减少原表行数，只是划分计算范围

**​​性能优化**​​：为 PARTITION BY和 ORDER BY中使用的列建立索引可以提高查询性能

**​​使用限制​**​：窗口函数原则上只能写在 SELECT子句中

## ✨ 面试思考
**​​面试官为什么问这个​**​：考察是否掌握高级SQL分析能力，能否使用窗口函数解决复杂的业务分析问题，以及是否理解不同窗口函数的适用场景。

**​​如何展现优势​**​：在回答时，不仅要解释窗口函数的概念，更要结合具体业务场景举例说明其应用价值。例如：
- "在分析用户行为时，我使用 ROW_NUMBER()来识别每个用户的最新活动"
- "为了计算销售额的移动平均，我使用 AVG() OVER()配合窗口框架来消除短期波动"
- "在用户分层分析中，我使用 NTILE(4)将用户按消费金额分为4个等级"