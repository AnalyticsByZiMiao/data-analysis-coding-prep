SQL 窗口函数学习笔记
1. 什么是窗口函数
窗口函数（Window Function），也称为分析函数（Analytic Function）或 OLAP 函数（Online Analytical Processing），用于对一组与当前行相关的行执行计算。
它与普通聚合函数的关键区别在于：​​窗口函数不会将多行合并为一行，而是为每一行返回一个值，同时保留原始行的所有细节​​。这使得它非常适合进行排名、移动平均、累计计算等分析操作。

2. 基本语法
窗口函数的核心语法结构如下：

<窗口函数> OVER (
    [PARTITION BY <列名1>, <列名2>, ...]
    [ORDER BY <排序列1> [ASC|DESC], <排序列2> [ASC|DESC], ...]
    [ROWS | RANGE BETWEEN <起始点> AND <结束点>]
)

• ​​<窗口函数>​​：可以是专用的窗口函数（如 RANK()）或聚合函数（如 SUM()）。

• ​​PARTITION BY​​：可选，用于将数据行划分为不同的分区（组），窗口函数会在每个分区内独立进行计算。省略时，整个结果集被视为一个分区。

• ​​ORDER BY​​：可选，用于指定分区内行的排序顺序。这对排名函数和计算累计值至关重要。

• ​​ROWS | RANGE BETWEEN​​：可选，用于定义窗口框架（Window Frame），即确定对于每一行，其计算所涉及的具体行范围。如果省略但指定了 ORDER BY，则默认框架是 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW。

3. 窗口框架（Window Frame）
窗口框架精确控制了参与计算的行范围。

• ​​ROWS​​：基于物理行偏移。

• ​​RANGE​​：基于逻辑值范围。

• 常用框架子句：

• ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW：从分区第一行到当前行（默认带 ORDER BY时）。

• ROWS BETWEEN 3 PRECEDING AND 1 FOLLOWING：当前行前3行到后1行。

• ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING：当前行到分区最后一行。

• RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND CURRENT ROW：值在（当前行值 - 1天）到当前行值之间的所有行。

4. 常用窗口函数分类
4.1 排序函数
• ​​ROW_NUMBER()​​：为分区内的每一行分配一个唯一的连续序号，即使值相同也会分配不同的编号（如：1, 2, 3, 4）。

• ​​RANK()​​：排名，值相同时排名相同，但后续排名会跳过相同的序号（如：1, 1, 3, 4）。

• ​​DENSE_RANK()​​：密集排名，值相同时排名相同，但后续排名连续不跳跃（如：1, 1, 2, 3）。

4.2 分布函数
• ​​NTILE(n)​​：将分区内的有序数据尽可能平均地分配到 n个桶中，并为每一行分配其所属的桶号（从1开始）。

• ​​PERCENT_RANK()​​：计算行的相对排名（百分比），公式为 (rank - 1) / (total_rows - 1)，范围 [0, 1]。

• ​​CUME_DIST()​​：计算行的累积分布，即值小于或等于当前行值的行数占总行数的比例，范围 (0, 1]。

4.3 偏移函数
• ​​LAG(expr, [offset], [default])​​：返回当前行之前 offset（默认为1）行的 expr值。如果不存在，则返回 default（默认为 NULL）。

• ​​LEAD(expr, [offset], [default])​​：返回当前行之后 offset（默认为1）行的 expr值。如果不存在，则返回 default（默认为 NULL）。

4.4 首尾值函数
• ​​FIRST_VALUE(expr)​​：返回窗口框架内第一行的 expr值。

• ​​LAST_VALUE(expr)​​：返回窗口框架内最后一行的 expr值。​​注意​​：默认框架（RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW）下，LAST_VALUE()会得到当前行的值，若要获取分区最后一行，需指定 ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING或 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING。

• ​​NTH_VALUE(expr, n)​​：返回窗口框架内第 n行的 expr值。


4.5 （聚合函数）
常见的聚合函数（如 SUM(), AVG(), COUNT(), MAX(), MIN()）也可作为窗口函数使用，此时它们会在定义的窗口上计算聚合值，而不是像 GROUP BY那样将行折叠。

5. 应用场景与示例
5.1 排名问题
-- 求每个部门内员工的薪水排名
SELECT
    department,
    employee,
    salary,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_salary,
    DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_rank_salary,
    ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num_salary
FROM employees;

5.2 Top-N 问题
-- 找出每个部门薪水最高的前3名员工
WITH ranked_employees AS (
    SELECT
        department,
        employee,
        salary,
        DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dr
    FROM employees
)
SELECT *
FROM ranked_employees
WHERE dr <= 3;

5.3 累计计算
-- 计算每个产品按日期排序的累计销售额
SELECT
    product_id,
    sale_date,
    daily_sales,
    SUM(daily_sales) OVER (
        PARTITION BY product_id
        ORDER BY sale_date
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_sales
FROM sales;

5.4 移动平均/移动求和
-- 计算近3天的移动平均销售额（包括当天）
SELECT
    product_id,
    sale_date,
    daily_sales,
    AVG(daily_sales) OVER (
        PARTITION BY product_id
        ORDER BY sale_date
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW
    ) AS moving_avg_3day
FROM sales;

5.5 访问相邻行的数据（同比/环比）
-- 计算月度销售额的环比增长
SELECT
    month,
    revenue,
    LAG(revenue, 1) OVER (ORDER BY month) AS prev_month_revenue,
    revenue - LAG(revenue, 1) OVER (ORDER BY month) AS mom_growth
FROM monthly_sales;

5.6 计算占比
-- 计算每个员工的薪水占其部门总薪水的比例
SELECT
    department,
    employee,
    salary,
    salary / SUM(salary) OVER (PARTITION BY department) * 100 AS salary_percentage
FROM employees;

6. 执行顺序与注意事项
• ​​SQL 逻辑执行顺序​​：窗口函数在标准 SQL 查询逻辑执行顺序中，通常在 WHERE, GROUP BY, HAVING之后，ORDER BY之前进行计算。这意味着窗口函数操作的是这些子句处理后的结果集。

• ​​PARTITION BY vs GROUP BY​​：GROUP BY会压缩行，每个分组只返回一行汇总结果。 PARTITION BY不会减少原表的行数，只是划分计算范围。

• ​​性能​​：为 PARTITION BY和 ORDER BY中使用的列建立索引可以提高窗口函数的查询性能 。

7. 总结
窗口函数是 SQL 中进行复杂数据分析的利器，它通过 OVER()子句提供了灵活的数据划分和计算窗口定义能力。掌握不同类型的窗口函数及其应用场景，可以让你更高效地处理排名、累计计算、移动分析、数据对比等高级查询需求，极大增强了 SQL 的分析表达能力。
